# 内部类
内部类的分类
1. 成员内部类
2. 静态内部类
3. 局部内部类
4. 匿名内部类
5. lambda表达式

## 一、 成员内部类
1. 访问修饰符：四种访问修饰级别都可以。
2. 成员特点：
    (1) 成员内部类的对象必须在外围类的对象的基础上才能得到，想要得到内部类对象，就要先创建外围类。
    (2) 成员内部类没有静态声明。没有静态成员变量、静态成员方法，其他和普通子类一样。
3. 访问特点：
    **(1) 在成员内部类中访问外围类成员**（访问不受限制）
    直接访问。因为成员内部类对象拥有外围类对象的引用作为成员变量。
    **(2) 在外围类中访问成员内部类成员**（访问不受限制）
        I. 在外围类的静态上下文中访问成员内部类成员
        没有任何对象，需要先创建外围类的对象，然后在外围类的基础上创建成员内部类的对象。
        ```
        InnerClazz ic = new EnclosedClazz().new InnerClazz();
        ```
        II. 在外围类的非静态上下文中访问成员内部类成员
        拥有外围类对象，只需要创建成员内部类即可。
    **(3) 在外部类中访问成员内部类成员**（访问受限制）
    无论是静态上下文还是非静态上下文都没有该成员内部类对象，需要先创建外围类对象，然后再在外围类对象的基础上创建成员内部类对象。
        ```
        EnclosedClazz.InnerClazz ic = new EnclosedClazz().new InnerClazz();
        ```
    



## 二、 静态内部类
静态内部类和外围类之间的访问都不受权限的限制，没有任何依赖关系，想要访问就创建各自对象即可。
1. 访问修饰符：四种访问修饰级别都可以。
2. 成员特点：
    和普通类没有区别。
3. 访问特点：
    **(1) 在静态内部类中访问外围类成员**（访问不受限制）
    创建外围类对象。
    
    **(2) 在外围类中访问静态内部类成员**（访问不受限制）
    创建静态内部类对象。
        
    **(3) 在外部类中访问成员内部类成员**（访问受限制）
    直接创建静态内部类对象
        ```
        EnclosedClazz.NestedClazz nc = new EnclosedClazz.NestedClazz();
        ```

## 三、 局部内部类
1. 访问权限修饰符：类似局部变量没有访问权限的概念。
2. 成员特点：
   和成员内部类完全一致，没有静态声明，可以定义用字面值常量赋值的**全局常量**（作用域的变量作为常量，事实常量）。
   > 该变量在作用域的其他使用场景也是作为常量吗？还是说只在内部类中作为常量。
3. 访问特点：
   **(1) 局部内部类访问外围类**
   I. 局部内部类在静态上下文中
   需要创建外围类对象
   II.局部内部类在非静态上下文中
   可以直接调用外围类成员
   **(2) 外围内部类访问局部内部类**
   受作用域的限制，必须在作用区内部才能访问局部内部类，创建对象。

4. 继承和实现

## 四、 匿名内部类
```java
语法:
 * // 局部位置
 * new 类名或者接口名(){
 *   // 某类名或接口名的子类的类体
 * };
 * // 局部位置
 ```

1. 创建的是“类名或接口名”的子类对象，该子类名字不知道，所以叫匿名内部类。
2. “{}”中可以重写父类的方法，也可以定义自己的方法。
3. 使用方法
    (1) 直接作为对象使用。
    (2) 用“类名或接口名”中的父类或接口类型引用接收该对象。
4. 匿名内部类不能定义构造器，因为类名是匿名的，写不出构造器。但是匿名类任然有编译器默认提供的无参构造器。
5. 当匿名内部类创建的是一个类的对象时
    "()"可以给父类构造器传参
    当创建的是接口的子类对象时
    "()"就没有用了。
6. 匿名内部类访问作用域内部的局部变量,**该局部变量是常量**
    该变量在作用域的其他使用场景也是作为常量吗？还是说只在内部类中作为常量。
7. 用途
    (1) 作为返回值
    (2) 作为形式参数

## 五、 lambda表达式
> lambda表达式是Java8的一个新特性，可以取代接口的匿名内部类，写出更简洁的代码。
1. 语法和基本使用

形参列表：强制子类实现的抽象方法的形参列表
“{}”：重写抽象方法的方法体。

    能够用lambda表达式创建子类对象的接口必须是功能接口(FunctionalInterface)
    > 功能接口的概念：
    > 指的是接口中，有且仅有一个强制子类实现的抽象方法的接口。、
    
    功能接口只有一个方法吗？只有一个抽象方法吗？
        (1) 功能接口中可以有默认方法和静态方法。
        (2) 如果一个抽象方法可以用Object类的某个方法作为默认实现，那么该抽象方法就不会强制子类实现。

2. 类型推断的方式
    (1) 直接用父类接口引用接收
    (2) 类似于强制类型转换
        ((接口的名字) lambda表达式)

    (3) 借助形参的数据类型（lambda表达式作为参数）
    (4) 借助方法的返回值类型（lambda表达式作为返回值）
3. 简化
    (1) "(形参列表)"中的形式参数数据类型可以省略。
    (2) “{}” 如果重写的方法体只有一条语句，就可以省略，如果这一句是return语句，可以直接省略return。
    (3) 方法引用
        用一个已经实现的方法作为lambda表达式抽象方法的实现
        I. 返回值类型
        功能接口中的抽象方法的
        返回值类型是void或基本数据类型，必须保持一致。
        返回值类型是引用数据类型，可以保持一致和返回它的子类。
        II.调用格式：不省略“->”
        (形参列表) -> 已实现方法的调用(形参列表);
        III.调用格式：省略“->”
        已实现方法的归属者:: 已实现的方法的方法名;
        已实现方法的归属者：静态方法属于类，成员方法属于对象



